/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./assets/application.css":
/*!********************************!*\
  !*** ./assets/application.css ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\nvar content = __webpack_require__(/*! !../node_modules/css-loader/dist/cjs.js!./application.css */ \"./node_modules/css-loader/dist/cjs.js!./assets/application.css\");\n\nif(typeof content === 'string') content = [[module.i, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = __webpack_require__(/*! ../node_modules/style-loader/lib/addStyles.js */ \"./node_modules/style-loader/lib/addStyles.js\")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(false) {}\n\n//# sourceURL=webpack:///./assets/application.css?");

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./assets/application.css":
/*!**********************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./assets/application.css ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\")(false);\n// Module\nexports.push([module.i, \"body{\\n  font: Helvetica,Arial,sans-serif;\\n  background: #e1e1e1;\\n}\\n.container {\\n  margin: 0 auto;\\n  width: 360px;\\n}\\n.chessfield {\\n  text-align: center;\\n  font-size: 24px;\\n  font-weight: bold;\\n  -webkit-box-shadow: 0px 9px 29px -8px rgba(0,0,0,0.75);\\n  -moz-box-shadow: 0px 9px 29px -8px rgba(0,0,0,0.75);\\n  box-shadow: 0px 9px 29px -8px rgba(0,0,0,0.75);\\n  border-radius: 3px;\\n  overflow: hidden;\\n}\\n\\n.chessfield .active {\\n  background: #f9a825!important;\\n}\\n\\n.chessfield table {\\n  border-collapse: collapse;\\n}\\n\\n.chessfield table, th, td {\\n  border: 0px solid #000;\\n}\\n\\n.chessfield td {\\n    padding: 3px;\\n    width: 30px;\\n    height: 30px;\\n}\\n\\n.chessfield tr:nth-child(odd) td:nth-child(even),\\n.chessfield tr:nth-child(even) td:nth-child(odd) {\\n    background: #4e342e;\\n}\\n\\n.chessfield tr .borders {\\n  background: #fff!important;\\n}\\n\", \"\"]);\n\n\n//# sourceURL=webpack:///./assets/application.css?./node_modules/css-loader/dist/cjs.js");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\n// eslint-disable-next-line func-names\n\nmodule.exports = function (useSourceMap) {\n  var list = []; // return the list of modules as css string\n\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = cssWithMappingToString(item, useSourceMap);\n\n      if (item[2]) {\n        return \"@media \".concat(item[2], \"{\").concat(content, \"}\");\n      }\n\n      return content;\n    }).join('');\n  }; // import a list of modules into the list\n  // eslint-disable-next-line func-names\n\n\n  list.i = function (modules, mediaQuery) {\n    if (typeof modules === 'string') {\n      // eslint-disable-next-line no-param-reassign\n      modules = [[null, modules, '']];\n    }\n\n    var alreadyImportedModules = {};\n\n    for (var i = 0; i < this.length; i++) {\n      // eslint-disable-next-line prefer-destructuring\n      var id = this[i][0];\n\n      if (id != null) {\n        alreadyImportedModules[id] = true;\n      }\n    }\n\n    for (var _i = 0; _i < modules.length; _i++) {\n      var item = modules[_i]; // skip already imported module\n      // this implementation is not 100% perfect for weird media query combinations\n      // when a module is imported multiple times with different media queries.\n      // I hope this will never occur (Hey this way we have smaller bundles)\n\n      if (item[0] == null || !alreadyImportedModules[item[0]]) {\n        if (mediaQuery && !item[2]) {\n          item[2] = mediaQuery;\n        } else if (mediaQuery) {\n          item[2] = \"(\".concat(item[2], \") and (\").concat(mediaQuery, \")\");\n        }\n\n        list.push(item);\n      }\n    }\n  };\n\n  return list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n  var content = item[1] || ''; // eslint-disable-next-line prefer-destructuring\n\n  var cssMapping = item[3];\n\n  if (!cssMapping) {\n    return content;\n  }\n\n  if (useSourceMap && typeof btoa === 'function') {\n    var sourceMapping = toComment(cssMapping);\n    var sourceURLs = cssMapping.sources.map(function (source) {\n      return \"/*# sourceURL=\".concat(cssMapping.sourceRoot).concat(source, \" */\");\n    });\n    return [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n  }\n\n  return [content].join('\\n');\n} // Adapted from convert-source-map (MIT)\n\n\nfunction toComment(sourceMap) {\n  // eslint-disable-next-line no-undef\n  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n  var data = \"sourceMappingURL=data:application/json;charset=utf-8;base64,\".concat(base64);\n  return \"/*# \".concat(data, \" */\");\n}\n\n//# sourceURL=webpack:///./node_modules/css-loader/dist/runtime/api.js?");

/***/ }),

/***/ "./node_modules/melanke-watchjs/src/watch.js":
/*!***************************************************!*\
  !*** ./node_modules/melanke-watchjs/src/watch.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\n * DEVELOPED BY\n * GIL LOPES BUENO\n * gilbueno.mail@gmail.com\n *\n * WORKS WITH:\n * IE8*, IE 9+, FF 4+, SF 5+, WebKit, CH 7+, OP 12+, BESEN, Rhino 1.7+\n * For IE8 (and other legacy browsers) WatchJS will use dirty checking  \n *\n * FORK:\n * https://github.com/melanke/Watch.JS\n *\n * LICENSE: MIT\n */\n\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n(function (factory) {\n  if (( false ? undefined : _typeof(exports)) === 'object') {\n    // Node. Does not work with strict CommonJS, but\n    // only CommonJS-like enviroments that support module.exports,\n    // like Node.\n    module.exports = factory();\n  } else if (true) {\n    // AMD. Register as an anonymous module.\n    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :\n\t\t\t\t__WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n})(function () {\n  var WatchJS = {\n    noMore: false,\n    // use WatchJS.suspend(obj) instead\n    useDirtyCheck: false,\n    // use only dirty checking to track changes.\n    preserveExistingSetters: false\n  },\n      lengthsubjects = [];\n  var dirtyChecklist = [];\n  var pendingChanges = []; // used coalesce changes from defineProperty and __defineSetter__\n\n  var supportDefineProperty = false;\n\n  try {\n    supportDefineProperty = Object.defineProperty && Object.defineProperty({}, 'x', {});\n  } catch (ex) {\n    /* not supported */\n  }\n\n  var isFunction = function isFunction(functionToCheck) {\n    var getType = {};\n    return functionToCheck && getType.toString.call(functionToCheck) == '[object Function]';\n  };\n\n  var isInt = function isInt(x) {\n    return x % 1 === 0;\n  };\n\n  var isArray = function isArray(obj) {\n    return Object.prototype.toString.call(obj) === '[object Array]';\n  };\n\n  var isObject = function isObject(obj) {\n    return {}.toString.apply(obj) === '[object Object]';\n  };\n\n  var getObjDiff = function getObjDiff(a, b) {\n    var aplus = [],\n        bplus = [];\n\n    if (!(typeof a == \"string\") && !(typeof b == \"string\")) {\n      if (isArray(a) && b) {\n        for (var i = 0; i < a.length; i++) {\n          if (b[i] === undefined) aplus.push(i);\n        }\n      } else {\n        for (var i in a) {\n          if (a.hasOwnProperty(i)) {\n            if (b && !b.hasOwnProperty(i)) {\n              aplus.push(i);\n            }\n          }\n        }\n      }\n\n      if (isArray(b) && a) {\n        for (var j = 0; j < b.length; j++) {\n          if (a[j] === undefined) bplus.push(j);\n        }\n      } else {\n        for (var j in b) {\n          if (b.hasOwnProperty(j)) {\n            if (a && !a.hasOwnProperty(j)) {\n              bplus.push(j);\n            }\n          }\n        }\n      }\n    }\n\n    return {\n      added: aplus,\n      removed: bplus\n    };\n  };\n\n  var clone = function clone(obj) {\n    if (null == obj || \"object\" != _typeof(obj)) {\n      return obj;\n    }\n\n    var copy = obj.constructor();\n\n    for (var attr in obj) {\n      copy[attr] = obj[attr];\n    }\n\n    return copy;\n  };\n\n  var getExistingSetter = function getExistingSetter(obj, propName) {\n    if (WatchJS.preserveExistingSetters) {\n      var existing = Object.getOwnPropertyDescriptor(obj, propName);\n      return existing.set;\n    }\n\n    return undefined;\n  };\n\n  var defineGetAndSet = function defineGetAndSet(obj, propName, getter, setter) {\n    try {\n      var existingSetter = getExistingSetter(obj, propName);\n      Object.defineProperty(obj, propName, {\n        get: getter,\n        set: function set(value) {\n          setter.call(this, value, true); // coalesce changes\n\n          if (existingSetter) {\n            existingSetter(value);\n          }\n        },\n        enumerable: true,\n        configurable: true\n      });\n    } catch (e1) {\n      try {\n        Object.prototype.__defineGetter__.call(obj, propName, getter);\n\n        Object.prototype.__defineSetter__.call(obj, propName, function (value) {\n          setter.call(this, value, true); // coalesce changes\n        });\n      } catch (e2) {\n        observeDirtyChanges(obj, propName, setter); //throw new Error(\"watchJS error: browser not supported :/\")\n      }\n    }\n  };\n\n  var defineProp = function defineProp(obj, propName, value) {\n    try {\n      Object.defineProperty(obj, propName, {\n        enumerable: false,\n        configurable: true,\n        writable: false,\n        value: value\n      });\n    } catch (error) {\n      obj[propName] = value;\n    }\n  };\n\n  var observeDirtyChanges = function observeDirtyChanges(obj, propName, setter) {\n    dirtyChecklist[dirtyChecklist.length] = {\n      prop: propName,\n      object: obj,\n      orig: clone(obj[propName]),\n      callback: setter\n    };\n  };\n\n  var watch = function watch() {\n    if (isFunction(arguments[1])) {\n      watchAll.apply(this, arguments);\n    } else if (isArray(arguments[1])) {\n      watchMany.apply(this, arguments);\n    } else {\n      watchOne.apply(this, arguments);\n    }\n  };\n\n  var watchAll = function watchAll(obj, watcher, level, addNRemove) {\n    if (typeof obj == \"string\" || !(obj instanceof Object) && !isArray(obj)) {\n      //accepts only objects and array (not string)\n      return;\n    }\n\n    if (isArray(obj)) {\n      defineWatcher(obj, \"__watchall__\", watcher, level); // watch all changes on the array\n\n      if (level === undefined || level > 0) {\n        for (var prop = 0; prop < obj.length; prop++) {\n          // watch objects in array\n          watchAll(obj[prop], watcher, level, addNRemove);\n        }\n      }\n    } else {\n      var prop,\n          props = [];\n\n      for (prop in obj) {\n        //for each attribute if obj is an object\n        if (prop == \"$val\" || !supportDefineProperty && prop === 'watchers') {\n          continue;\n        }\n\n        if (Object.prototype.hasOwnProperty.call(obj, prop)) {\n          props.push(prop); //put in the props\n        }\n      }\n\n      watchMany(obj, props, watcher, level, addNRemove); //watch all items of the props\n    }\n\n    if (addNRemove) {\n      pushToLengthSubjects(obj, \"$$watchlengthsubjectroot\", watcher, level);\n    }\n  };\n\n  var watchMany = function watchMany(obj, props, watcher, level, addNRemove) {\n    if (typeof obj == \"string\" || !(obj instanceof Object) && !isArray(obj)) {\n      //accepts only objects and array (not string)\n      return;\n    }\n\n    for (var i = 0; i < props.length; i++) {\n      //watch each property\n      var prop = props[i];\n      watchOne(obj, prop, watcher, level, addNRemove);\n    }\n  };\n\n  var watchOne = function watchOne(obj, prop, watcher, level, addNRemove) {\n    if (typeof obj == \"string\" || !(obj instanceof Object) && !isArray(obj)) {\n      //accepts only objects and array (not string)\n      return;\n    }\n\n    if (isFunction(obj[prop])) {\n      //dont watch if it is a function\n      return;\n    }\n\n    if (obj[prop] != null && (level === undefined || level > 0)) {\n      watchAll(obj[prop], watcher, level !== undefined ? level - 1 : level); //recursively watch all attributes of this\n    }\n\n    defineWatcher(obj, prop, watcher, level);\n\n    if (addNRemove && (level === undefined || level > 0)) {\n      pushToLengthSubjects(obj, prop, watcher, level);\n    }\n  };\n\n  var unwatch = function unwatch() {\n    if (isFunction(arguments[1])) {\n      unwatchAll.apply(this, arguments);\n    } else if (isArray(arguments[1])) {\n      unwatchMany.apply(this, arguments);\n    } else {\n      unwatchOne.apply(this, arguments);\n    }\n  };\n\n  var unwatchAll = function unwatchAll(obj, watcher) {\n    if (obj instanceof String || !(obj instanceof Object) && !isArray(obj)) {\n      //accepts only objects and array (not string)\n      return;\n    }\n\n    if (isArray(obj)) {\n      var props = ['__watchall__'];\n\n      for (var prop = 0; prop < obj.length; prop++) {\n        //for each item if obj is an array\n        props.push(prop); //put in the props\n      }\n\n      unwatchMany(obj, props, watcher); //watch all itens of the props\n    } else {\n      var unwatchPropsInObject = function unwatchPropsInObject(obj2) {\n        var props = [];\n\n        for (var prop2 in obj2) {\n          //for each attribute if obj is an object\n          if (obj2.hasOwnProperty(prop2)) {\n            if (obj2[prop2] instanceof Object) {\n              unwatchPropsInObject(obj2[prop2]); //recurs into object props\n            } else {\n              props.push(prop2); //put in the props\n            }\n          }\n        }\n\n        unwatchMany(obj2, props, watcher); //unwatch all of the props\n      };\n\n      unwatchPropsInObject(obj);\n    }\n  };\n\n  var unwatchMany = function unwatchMany(obj, props, watcher) {\n    for (var prop2 in props) {\n      //watch each attribute of \"props\" if is an object\n      if (props.hasOwnProperty(prop2)) {\n        unwatchOne(obj, props[prop2], watcher);\n      }\n    }\n  };\n\n  var timeouts = [],\n      timerID = null;\n\n  function clearTimerID() {\n    timerID = null;\n\n    for (var i = 0; i < timeouts.length; i++) {\n      timeouts[i]();\n    }\n\n    timeouts.length = 0;\n  }\n\n  var getTimerID = function getTimerID() {\n    if (!timerID) {\n      timerID = setTimeout(clearTimerID);\n    }\n\n    return timerID;\n  };\n\n  var registerTimeout = function registerTimeout(fn) {\n    // register function to be called on timeout\n    if (timerID == null) getTimerID();\n    timeouts[timeouts.length] = fn;\n  }; // Track changes made to an array, object or an object's property \n  // and invoke callback with a single change object containing type, value, oldvalue and array splices\n  // Syntax: \n  //      trackChange(obj, callback, recursive, addNRemove)\n  //      trackChange(obj, prop, callback, recursive, addNRemove)\n\n\n  var trackChange = function trackChange() {\n    var fn = isFunction(arguments[2]) ? trackProperty : trackObject;\n    fn.apply(this, arguments);\n  }; // track changes made to an object and invoke callback with a single change object containing type, value and array splices\n\n\n  var trackObject = function trackObject(obj, callback, recursive, addNRemove) {\n    var change = null,\n        lastTimerID = -1;\n    var isArr = isArray(obj);\n\n    var level,\n        fn = function fn(prop, action, newValue, oldValue) {\n      var timerID = getTimerID();\n\n      if (lastTimerID !== timerID) {\n        // check if timer has changed since last update\n        lastTimerID = timerID;\n        change = {\n          type: 'update'\n        };\n        change['value'] = obj;\n        change['splices'] = null;\n        registerTimeout(function () {\n          callback.call(this, change);\n          change = null;\n        });\n      } // create splices for array changes\n\n\n      if (isArr && obj === this && change !== null) {\n        if (action === 'pop' || action === 'shift') {\n          newValue = [];\n          oldValue = [oldValue];\n        } else if (action === 'push' || action === 'unshift') {\n          newValue = [newValue];\n          oldValue = [];\n        } else if (action !== 'splice') {\n          return; // return here - for reverse and sort operations we don't need to return splices. a simple update will do\n        }\n\n        if (!change.splices) change.splices = [];\n        change.splices[change.splices.length] = {\n          index: prop,\n          deleteCount: oldValue ? oldValue.length : 0,\n          addedCount: newValue ? newValue.length : 0,\n          added: newValue,\n          deleted: oldValue\n        };\n      }\n    };\n\n    level = recursive == true ? undefined : 0;\n    watchAll(obj, fn, level, addNRemove);\n  }; // track changes made to the property of an object and invoke callback with a single change object containing type, value, oldvalue and splices\n\n\n  var trackProperty = function trackProperty(obj, prop, callback, recursive, addNRemove) {\n    if (obj && prop) {\n      watchOne(obj, prop, function (prop, action, newvalue, oldvalue) {\n        var change = {\n          type: 'update'\n        };\n        change['value'] = newvalue;\n        change['oldvalue'] = oldvalue;\n\n        if (recursive && isObject(newvalue) || isArray(newvalue)) {\n          trackObject(newvalue, callback, recursive, addNRemove);\n        }\n\n        callback.call(this, change);\n      }, 0);\n\n      if (recursive && isObject(obj[prop]) || isArray(obj[prop])) {\n        trackObject(obj[prop], callback, recursive, addNRemove);\n      }\n    }\n  };\n\n  var defineWatcher = function defineWatcher(obj, prop, watcher, level) {\n    var newWatcher = false;\n    var isArr = isArray(obj);\n\n    if (!obj.watchers) {\n      defineProp(obj, \"watchers\", {});\n\n      if (isArr) {\n        // watch array functions\n        watchFunctions(obj, function (index, action, newValue, oldValue) {\n          addPendingChange(obj, index, action, newValue, oldValue);\n\n          if (level !== 0 && newValue && (isObject(newValue) || isArray(newValue))) {\n            var i,\n                n,\n                ln,\n                wAll,\n                watchList = obj.watchers[prop];\n\n            if (wAll = obj.watchers['__watchall__']) {\n              watchList = watchList ? watchList.concat(wAll) : wAll;\n            }\n\n            ln = watchList ? watchList.length : 0;\n\n            for (i = 0; i < ln; i++) {\n              if (action !== 'splice') {\n                watchAll(newValue, watchList[i], level === undefined ? level : level - 1);\n              } else {\n                // watch spliced values\n                for (n = 0; n < newValue.length; n++) {\n                  watchAll(newValue[n], watchList[i], level === undefined ? level : level - 1);\n                }\n              }\n            }\n          }\n        });\n      }\n    }\n\n    if (!obj.watchers[prop]) {\n      obj.watchers[prop] = [];\n      if (!isArr) newWatcher = true;\n    }\n\n    for (var i = 0; i < obj.watchers[prop].length; i++) {\n      if (obj.watchers[prop][i] === watcher) {\n        return;\n      }\n    }\n\n    obj.watchers[prop].push(watcher); //add the new watcher to the watchers array\n\n    if (newWatcher) {\n      var val = obj[prop];\n\n      var getter = function getter() {\n        return val;\n      };\n\n      var setter = function setter(newval, delayWatcher) {\n        var oldval = val;\n        val = newval;\n\n        if (level !== 0 && obj[prop] && (isObject(obj[prop]) || isArray(obj[prop])) && !obj[prop].watchers) {\n          // watch sub properties\n          var i,\n              ln = obj.watchers[prop].length;\n\n          for (i = 0; i < ln; i++) {\n            watchAll(obj[prop], obj.watchers[prop][i], level === undefined ? level : level - 1);\n          }\n        } //watchFunctions(obj, prop);\n\n\n        if (isSuspended(obj, prop)) {\n          resume(obj, prop);\n          return;\n        }\n\n        if (!WatchJS.noMore) {\n          // this does not work with Object.observe\n          //if (JSON.stringify(oldval) !== JSON.stringify(newval)) {\n          if (oldval !== newval) {\n            if (!delayWatcher) {\n              callWatchers(obj, prop, \"set\", newval, oldval);\n            } else {\n              addPendingChange(obj, prop, \"set\", newval, oldval);\n            }\n\n            WatchJS.noMore = false;\n          }\n        }\n      };\n\n      if (WatchJS.useDirtyCheck) {\n        observeDirtyChanges(obj, prop, setter);\n      } else {\n        defineGetAndSet(obj, prop, getter, setter);\n      }\n    }\n  };\n\n  var callWatchers = function callWatchers(obj, prop, action, newval, oldval) {\n    if (prop !== undefined) {\n      var ln,\n          wl,\n          watchList = obj.watchers[prop];\n\n      if (wl = obj.watchers['__watchall__']) {\n        watchList = watchList ? watchList.concat(wl) : wl;\n      }\n\n      ln = watchList ? watchList.length : 0;\n\n      for (var wr = 0; wr < ln; wr++) {\n        watchList[wr].call(obj, prop, action, newval, oldval);\n      }\n    } else {\n      for (var prop in obj) {\n        //call all\n        if (obj.hasOwnProperty(prop)) {\n          callWatchers(obj, prop, action, newval, oldval);\n        }\n      }\n    }\n  };\n\n  var methodNames = ['pop', 'push', 'reverse', 'shift', 'sort', 'slice', 'unshift', 'splice'];\n\n  var defineArrayMethodWatcher = function defineArrayMethodWatcher(obj, original, methodName, callback) {\n    defineProp(obj, methodName, function () {\n      var index = 0;\n      var i, newValue, oldValue, response; // get values before splicing array \n\n      if (methodName === 'splice') {\n        var start = arguments[0];\n        var end = start + arguments[1];\n        oldValue = obj.slice(start, end);\n        newValue = [];\n\n        for (i = 2; i < arguments.length; i++) {\n          newValue[i - 2] = arguments[i];\n        }\n\n        index = start;\n      } else {\n        newValue = arguments.length > 0 ? arguments[0] : undefined;\n      }\n\n      response = original.apply(obj, arguments);\n\n      if (methodName !== 'slice') {\n        if (methodName === 'pop') {\n          oldValue = response;\n          index = obj.length;\n        } else if (methodName === 'push') {\n          index = obj.length - 1;\n        } else if (methodName === 'shift') {\n          oldValue = response;\n        } else if (methodName !== 'unshift' && newValue === undefined) {\n          newValue = response;\n        }\n\n        callback.call(obj, index, methodName, newValue, oldValue);\n      }\n\n      return response;\n    });\n  };\n\n  var watchFunctions = function watchFunctions(obj, callback) {\n    if (!isFunction(callback) || !obj || obj instanceof String || !isArray(obj)) {\n      return;\n    }\n\n    for (var i = methodNames.length, methodName; i--;) {\n      methodName = methodNames[i];\n      defineArrayMethodWatcher(obj, obj[methodName], methodName, callback);\n    }\n  };\n\n  var unwatchOne = function unwatchOne(obj, prop, watcher) {\n    if (prop) {\n      if (obj.watchers && obj.watchers[prop]) {\n        if (watcher === undefined) {\n          delete obj.watchers[prop]; // remove all property watchers\n        } else {\n          for (var i = 0; i < obj.watchers[prop].length; i++) {\n            var w = obj.watchers[prop][i];\n\n            if (w == watcher) {\n              obj.watchers[prop].splice(i, 1);\n            }\n          }\n        }\n      }\n    } else {\n      delete obj.watchers;\n    }\n\n    removeFromLengthSubjects(obj, prop, watcher);\n    removeFromDirtyChecklist(obj, prop);\n  }; // suspend watchers until next update cycle\n\n\n  var suspend = function suspend(obj, prop) {\n    if (obj.watchers) {\n      var name = '__wjs_suspend__' + (prop !== undefined ? prop : '');\n      obj.watchers[name] = true;\n    }\n  };\n\n  var isSuspended = function isSuspended(obj, prop) {\n    return obj.watchers && (obj.watchers['__wjs_suspend__'] || obj.watchers['__wjs_suspend__' + prop]);\n  }; // resumes preivously suspended watchers\n\n\n  var resume = function resume(obj, prop) {\n    registerTimeout(function () {\n      delete obj.watchers['__wjs_suspend__'];\n      delete obj.watchers['__wjs_suspend__' + prop];\n    });\n  };\n\n  var pendingTimerID = null;\n\n  var addPendingChange = function addPendingChange(obj, prop, mode, newval, oldval) {\n    pendingChanges[pendingChanges.length] = {\n      obj: obj,\n      prop: prop,\n      mode: mode,\n      newval: newval,\n      oldval: oldval\n    };\n\n    if (pendingTimerID === null) {\n      pendingTimerID = setTimeout(applyPendingChanges);\n    }\n  };\n\n  var applyPendingChanges = function applyPendingChanges() {\n    // apply pending changes\n    var change = null;\n    pendingTimerID = null;\n\n    for (var i = 0; i < pendingChanges.length; i++) {\n      change = pendingChanges[i];\n      callWatchers(change.obj, change.prop, change.mode, change.newval, change.oldval);\n    }\n\n    if (change) {\n      pendingChanges = [];\n      change = null;\n    }\n  };\n\n  var loop = function loop() {\n    // check for new or deleted props\n    for (var i = 0; i < lengthsubjects.length; i++) {\n      var subj = lengthsubjects[i];\n\n      if (subj.prop === \"$$watchlengthsubjectroot\") {\n        var difference = getObjDiff(subj.obj, subj.actual);\n\n        if (difference.added.length || difference.removed.length) {\n          if (difference.added.length) {\n            watchMany(subj.obj, difference.added, subj.watcher, subj.level - 1, true);\n          }\n\n          subj.watcher.call(subj.obj, \"root\", \"differentattr\", difference, subj.actual);\n        }\n\n        subj.actual = clone(subj.obj);\n      } else {\n        var difference = getObjDiff(subj.obj[subj.prop], subj.actual);\n\n        if (difference.added.length || difference.removed.length) {\n          if (difference.added.length) {\n            for (var j = 0; j < subj.obj.watchers[subj.prop].length; j++) {\n              watchMany(subj.obj[subj.prop], difference.added, subj.obj.watchers[subj.prop][j], subj.level - 1, true);\n            }\n          }\n\n          callWatchers(subj.obj, subj.prop, \"differentattr\", difference, subj.actual);\n        }\n\n        subj.actual = clone(subj.obj[subj.prop]);\n      }\n    } // start dirty check\n\n\n    var n, value;\n\n    if (dirtyChecklist.length > 0) {\n      for (var i = 0; i < dirtyChecklist.length; i++) {\n        n = dirtyChecklist[i];\n        value = n.object[n.prop];\n\n        if (!compareValues(n.orig, value)) {\n          n.orig = clone(value);\n          n.callback(value);\n        }\n      }\n    }\n  };\n\n  var compareValues = function compareValues(a, b) {\n    var i,\n        state = true;\n\n    if (a !== b) {\n      if (isObject(a)) {\n        for (i in a) {\n          if (!supportDefineProperty && i === 'watchers') continue;\n\n          if (a[i] !== b[i]) {\n            state = false;\n            break;\n          }\n\n          ;\n        }\n      } else {\n        state = false;\n      }\n    }\n\n    return state;\n  };\n\n  var pushToLengthSubjects = function pushToLengthSubjects(obj, prop, watcher, level) {\n    var actual;\n\n    if (prop === \"$$watchlengthsubjectroot\") {\n      actual = clone(obj);\n    } else {\n      actual = clone(obj[prop]);\n    }\n\n    lengthsubjects.push({\n      obj: obj,\n      prop: prop,\n      actual: actual,\n      watcher: watcher,\n      level: level\n    });\n  };\n\n  var removeFromLengthSubjects = function removeFromLengthSubjects(obj, prop, watcher) {\n    for (var i = 0; i < lengthsubjects.length; i++) {\n      var subj = lengthsubjects[i];\n\n      if (subj.obj == obj) {\n        if (!prop || subj.prop == prop) {\n          if (!watcher || subj.watcher == watcher) {\n            // if we splice off one item at position i\n            // we need to decrement i as the array is one item shorter\n            // so when we increment i in the loop statement we\n            // will land at the correct index.\n            // if it's not decremented, you won't delete all length subjects\n            lengthsubjects.splice(i--, 1);\n          }\n        }\n      }\n    }\n  };\n\n  var removeFromDirtyChecklist = function removeFromDirtyChecklist(obj, prop) {\n    var notInUse;\n\n    for (var i = 0; i < dirtyChecklist.length; i++) {\n      var n = dirtyChecklist[i];\n      var watchers = n.object.watchers;\n      notInUse = n.object == obj && (!prop || n.prop == prop) && watchers && (!prop || !watchers[prop] || watchers[prop].length == 0);\n\n      if (notInUse) {\n        // we use the same syntax as in removeFromLengthSubjects\n        dirtyChecklist.splice(i--, 1);\n      }\n    }\n  };\n\n  setInterval(loop, 50);\n  WatchJS.watch = watch;\n  WatchJS.unwatch = unwatch;\n  WatchJS.callWatchers = callWatchers;\n  WatchJS.suspend = suspend; // suspend watchers    \n\n  WatchJS.onChange = trackChange; // track changes made to object or  it's property and return a single change object\n\n  return WatchJS;\n});\n\n//# sourceURL=webpack:///./node_modules/melanke-watchjs/src/watch.js?");

/***/ }),

/***/ "./node_modules/style-loader/lib/addStyles.js":
/*!****************************************************!*\
  !*** ./node_modules/style-loader/lib/addStyles.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\nvar stylesInDom = {};\n\nvar\tmemoize = function (fn) {\n\tvar memo;\n\n\treturn function () {\n\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\treturn memo;\n\t};\n};\n\nvar isOldIE = memoize(function () {\n\t// Test for IE <= 9 as proposed by Browserhacks\n\t// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n\t// Tests for existence of standard globals is to allow style-loader\n\t// to operate correctly into non-standard environments\n\t// @see https://github.com/webpack-contrib/style-loader/issues/177\n\treturn window && document && document.all && !window.atob;\n});\n\nvar getTarget = function (target, parent) {\n  if (parent){\n    return parent.querySelector(target);\n  }\n  return document.querySelector(target);\n};\n\nvar getElement = (function (fn) {\n\tvar memo = {};\n\n\treturn function(target, parent) {\n                // If passing function in options, then use it for resolve \"head\" element.\n                // Useful for Shadow Root style i.e\n                // {\n                //   insertInto: function () { return document.querySelector(\"#foo\").shadowRoot }\n                // }\n                if (typeof target === 'function') {\n                        return target();\n                }\n                if (typeof memo[target] === \"undefined\") {\n\t\t\tvar styleTarget = getTarget.call(this, target, parent);\n\t\t\t// Special case to return head of iframe instead of iframe itself\n\t\t\tif (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n\t\t\t\ttry {\n\t\t\t\t\t// This will throw an exception if access to iframe is blocked\n\t\t\t\t\t// due to cross-origin restrictions\n\t\t\t\t\tstyleTarget = styleTarget.contentDocument.head;\n\t\t\t\t} catch(e) {\n\t\t\t\t\tstyleTarget = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmemo[target] = styleTarget;\n\t\t}\n\t\treturn memo[target]\n\t};\n})();\n\nvar singleton = null;\nvar\tsingletonCounter = 0;\nvar\tstylesInsertedAtTop = [];\n\nvar\tfixUrls = __webpack_require__(/*! ./urls */ \"./node_modules/style-loader/lib/urls.js\");\n\nmodule.exports = function(list, options) {\n\tif (typeof DEBUG !== \"undefined\" && DEBUG) {\n\t\tif (typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t}\n\n\toptions = options || {};\n\n\toptions.attrs = typeof options.attrs === \"object\" ? options.attrs : {};\n\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (!options.singleton && typeof options.singleton !== \"boolean\") options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the <head> element\n        if (!options.insertInto) options.insertInto = \"head\";\n\n\t// By default, add <style> tags to the bottom of the target\n\tif (!options.insertAt) options.insertAt = \"bottom\";\n\n\tvar styles = listToStyles(list, options);\n\n\taddStylesToDom(styles, options);\n\n\treturn function update (newList) {\n\t\tvar mayRemove = [];\n\n\t\tfor (var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList, options);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\n\t\tfor (var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();\n\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n};\n\nfunction addStylesToDom (styles, options) {\n\tfor (var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles (list, options) {\n\tvar styles = [];\n\tvar newStyles = {};\n\n\tfor (var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = options.base ? item[0] + options.base : item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\n\t\tif(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse newStyles[id].parts.push(part);\n\t}\n\n\treturn styles;\n}\n\nfunction insertStyleElement (options, style) {\n\tvar target = getElement(options.insertInto)\n\n\tif (!target) {\n\t\tthrow new Error(\"Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.\");\n\t}\n\n\tvar lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];\n\n\tif (options.insertAt === \"top\") {\n\t\tif (!lastStyleElementInsertedAtTop) {\n\t\t\ttarget.insertBefore(style, target.firstChild);\n\t\t} else if (lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\ttarget.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\ttarget.appendChild(style);\n\t\t}\n\t\tstylesInsertedAtTop.push(style);\n\t} else if (options.insertAt === \"bottom\") {\n\t\ttarget.appendChild(style);\n\t} else if (typeof options.insertAt === \"object\" && options.insertAt.before) {\n\t\tvar nextSibling = getElement(options.insertAt.before, target);\n\t\ttarget.insertBefore(style, nextSibling);\n\t} else {\n\t\tthrow new Error(\"[Style Loader]\\n\\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\\n Must be 'top', 'bottom', or Object.\\n (https://github.com/webpack-contrib/style-loader#insertat)\\n\");\n\t}\n}\n\nfunction removeStyleElement (style) {\n\tif (style.parentNode === null) return false;\n\tstyle.parentNode.removeChild(style);\n\n\tvar idx = stylesInsertedAtTop.indexOf(style);\n\tif(idx >= 0) {\n\t\tstylesInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement (options) {\n\tvar style = document.createElement(\"style\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\n\tif(options.attrs.nonce === undefined) {\n\t\tvar nonce = getNonce();\n\t\tif (nonce) {\n\t\t\toptions.attrs.nonce = nonce;\n\t\t}\n\t}\n\n\taddAttrs(style, options.attrs);\n\tinsertStyleElement(options, style);\n\n\treturn style;\n}\n\nfunction createLinkElement (options) {\n\tvar link = document.createElement(\"link\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\toptions.attrs.rel = \"stylesheet\";\n\n\taddAttrs(link, options.attrs);\n\tinsertStyleElement(options, link);\n\n\treturn link;\n}\n\nfunction addAttrs (el, attrs) {\n\tObject.keys(attrs).forEach(function (key) {\n\t\tel.setAttribute(key, attrs[key]);\n\t});\n}\n\nfunction getNonce() {\n\tif (false) {}\n\n\treturn __webpack_require__.nc;\n}\n\nfunction addStyle (obj, options) {\n\tvar style, update, remove, result;\n\n\t// If a transform function was defined, run it on the css\n\tif (options.transform && obj.css) {\n\t    result = typeof options.transform === 'function'\n\t\t ? options.transform(obj.css) \n\t\t : options.transform.default(obj.css);\n\n\t    if (result) {\n\t    \t// If transform returns a value, use that instead of the original css.\n\t    \t// This allows running runtime transformations on the css.\n\t    \tobj.css = result;\n\t    } else {\n\t    \t// If the transform function returns a falsy value, don't add this css.\n\t    \t// This allows conditional loading of css\n\t    \treturn function() {\n\t    \t\t// noop\n\t    \t};\n\t    }\n\t}\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\n\t\tstyle = singleton || (singleton = createStyleElement(options));\n\n\t\tupdate = applyToSingletonTag.bind(null, style, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, style, styleIndex, true);\n\n\t} else if (\n\t\tobj.sourceMap &&\n\t\ttypeof URL === \"function\" &&\n\t\ttypeof URL.createObjectURL === \"function\" &&\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\n\t\ttypeof Blob === \"function\" &&\n\t\ttypeof btoa === \"function\"\n\t) {\n\t\tstyle = createLinkElement(options);\n\t\tupdate = updateLink.bind(null, style, options);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\n\t\t\tif(style.href) URL.revokeObjectURL(style.href);\n\t\t};\n\t} else {\n\t\tstyle = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, style);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle (newObj) {\n\t\tif (newObj) {\n\t\t\tif (\n\t\t\t\tnewObj.css === obj.css &&\n\t\t\t\tnewObj.media === obj.media &&\n\t\t\t\tnewObj.sourceMap === obj.sourceMap\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\n\t\treturn textStore.filter(Boolean).join('\\n');\n\t};\n})();\n\nfunction applyToSingletonTag (style, index, remove, obj) {\n\tvar css = remove ? \"\" : obj.css;\n\n\tif (style.styleSheet) {\n\t\tstyle.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = style.childNodes;\n\n\t\tif (childNodes[index]) style.removeChild(childNodes[index]);\n\n\t\tif (childNodes.length) {\n\t\t\tstyle.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyle.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag (style, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\n\tif(media) {\n\t\tstyle.setAttribute(\"media\", media)\n\t}\n\n\tif(style.styleSheet) {\n\t\tstyle.styleSheet.cssText = css;\n\t} else {\n\t\twhile(style.firstChild) {\n\t\t\tstyle.removeChild(style.firstChild);\n\t\t}\n\n\t\tstyle.appendChild(document.createTextNode(css));\n\t}\n}\n\nfunction updateLink (link, options, obj) {\n\tvar css = obj.css;\n\tvar sourceMap = obj.sourceMap;\n\n\t/*\n\t\tIf convertToAbsoluteUrls isn't defined, but sourcemaps are enabled\n\t\tand there is no publicPath defined then lets turn convertToAbsoluteUrls\n\t\ton by default.  Otherwise default to the convertToAbsoluteUrls option\n\t\tdirectly\n\t*/\n\tvar autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;\n\n\tif (options.convertToAbsoluteUrls || autoFixUrls) {\n\t\tcss = fixUrls(css);\n\t}\n\n\tif (sourceMap) {\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t}\n\n\tvar blob = new Blob([css], { type: \"text/css\" });\n\n\tvar oldSrc = link.href;\n\n\tlink.href = URL.createObjectURL(blob);\n\n\tif(oldSrc) URL.revokeObjectURL(oldSrc);\n}\n\n\n//# sourceURL=webpack:///./node_modules/style-loader/lib/addStyles.js?");

/***/ }),

/***/ "./node_modules/style-loader/lib/urls.js":
/*!***********************************************!*\
  !*** ./node_modules/style-loader/lib/urls.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * When source maps are enabled, `style-loader` uses a link element with a data-uri to\n * embed the css on the page. This breaks all relative urls because now they are relative to a\n * bundle instead of the current page.\n *\n * One solution is to only use full urls, but that may be impossible.\n *\n * Instead, this function \"fixes\" the relative urls to be absolute according to the current page location.\n *\n * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.\n *\n */\nmodule.exports = function (css) {\n  // get current location\n  var location = typeof window !== \"undefined\" && window.location;\n\n  if (!location) {\n    throw new Error(\"fixUrls requires window.location\");\n  } // blank or null?\n\n\n  if (!css || typeof css !== \"string\") {\n    return css;\n  }\n\n  var baseUrl = location.protocol + \"//\" + location.host;\n  var currentDir = baseUrl + location.pathname.replace(/\\/[^\\/]*$/, \"/\"); // convert each url(...)\n\n  /*\n  This regular expression is just a way to recursively match brackets within\n  a string.\n  \t /url\\s*\\(  = Match on the word \"url\" with any whitespace after it and then a parens\n     (  = Start a capturing group\n       (?:  = Start a non-capturing group\n           [^)(]  = Match anything that isn't a parentheses\n           |  = OR\n           \\(  = Match a start parentheses\n               (?:  = Start another non-capturing groups\n                   [^)(]+  = Match anything that isn't a parentheses\n                   |  = OR\n                   \\(  = Match a start parentheses\n                       [^)(]*  = Match anything that isn't a parentheses\n                   \\)  = Match a end parentheses\n               )  = End Group\n               *\\) = Match anything and then a close parens\n           )  = Close non-capturing group\n           *  = Match anything\n        )  = Close capturing group\n   \\)  = Match a close parens\n  \t /gi  = Get all matches, not the first.  Be case insensitive.\n   */\n\n  var fixedCss = css.replace(/url\\s*\\(((?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)\\)/gi, function (fullMatch, origUrl) {\n    // strip quotes (if they exist)\n    var unquotedOrigUrl = origUrl.trim().replace(/^\"(.*)\"$/, function (o, $1) {\n      return $1;\n    }).replace(/^'(.*)'$/, function (o, $1) {\n      return $1;\n    }); // already a full url? no change\n\n    if (/^(#|data:|http:\\/\\/|https:\\/\\/|file:\\/\\/\\/|\\s*$)/i.test(unquotedOrigUrl)) {\n      return fullMatch;\n    } // convert the url to a full url\n\n\n    var newUrl;\n\n    if (unquotedOrigUrl.indexOf(\"//\") === 0) {\n      //TODO: should we add protocol?\n      newUrl = unquotedOrigUrl;\n    } else if (unquotedOrigUrl.indexOf(\"/\") === 0) {\n      // path should be relative to the base url\n      newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'\n    } else {\n      // path should be relative to current directory\n      newUrl = currentDir + unquotedOrigUrl.replace(/^\\.\\//, \"\"); // Strip leading './'\n    } // send back the fixed url(...)\n\n\n    return \"url(\" + JSON.stringify(newUrl) + \")\";\n  }); // send back the fixed css\n\n  return fixedCss;\n};\n\n//# sourceURL=webpack:///./node_modules/style-loader/lib/urls.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _watcher__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./watcher */ \"./src/watcher.js\");\n\n\nvar app = function app() {\n  var initialChessColls = [],\n      initialChessRows = {};\n  var rowLength = 10;\n  var collLength = 10;\n\n  for (var i = 0; i < collLength; i += 1) {\n    initialChessColls.push('');\n  }\n\n  for (var _i = 0; _i < rowLength; _i += 1) {\n    initialChessRows[_i] = initialChessColls;\n  }\n\n  initialChessRows['9'] = [' ', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', ' '];\n  initialChessRows['8'] = ['1', '♖', '♘', '♗', '♕', '♔', '♗', '♘', '♖', '1'];\n  initialChessRows['7'] = ['2', '♙', '♙', '♙', '♙', '♙', '♙', '♙', '♙', '2'];\n  initialChessRows['6'] = ['3', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '3'];\n  initialChessRows['5'] = ['4', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '4'];\n  initialChessRows['4'] = ['5', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '5'];\n  initialChessRows['3'] = ['6', ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ', '6'];\n  initialChessRows['2'] = ['7', '♟', '♟', '♟', '♟', '♟', '♟', '♟', '♟', '7'];\n  initialChessRows['1'] = ['8', '♜', '♞', '♝', '♛', '♚', '♝', '♞', '♜', '8'];\n  initialChessRows['0'] = [' ', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', ' '];\n  console.log(initialChessRows);\n  var appState = {\n    chessField: [],\n    checkedItem: {},\n    targetItem: {},\n    action: 'getItem'\n  };\n\n  var controls = function controls(formCurrentState) {\n    var state = formCurrentState;\n    var formInput = document.querySelector('#chess');\n    formInput.addEventListener('click', function (e) {\n      var target = e.target;\n      var tagetClasses = target.classList;\n\n      if (!tagetClasses.contains('borders') && tagetClasses.contains('item')) {\n        var elText = e.target.textContent;\n        var elId = e.target.id;\n\n        if (state.action === 'getItem') {\n          if (elText === ' ') {\n            // Не даем брать 'пустые' поля\n            return;\n          }\n\n          state.checkedItem = {\n            elText: elText,\n            elId: elId\n          };\n          state.action = 'setItem';\n          return;\n        }\n\n        if (state.action === 'setItem') {\n          state.targetItem = {\n            elText: elText,\n            elId: elId\n          };\n          state.action = 'getItem';\n        }\n      } // if (target.c)\n      // if (isURL(input) && !state.feeds.includes(input)) {\n      //   rssForm.validate();\n      // } else {\n      //   rssForm.invalidate();\n      // }\n\n    });\n  };\n\n  controls(appState);\n  Object(_watcher__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(appState);\n  appState.chessField = initialChessRows;\n};\n\napp();\n\n//# sourceURL=webpack:///./src/index.js?");

/***/ }),

/***/ "./src/watcher.js":
/*!************************!*\
  !*** ./src/watcher.js ***!
  \************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var melanke_watchjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! melanke-watchjs */ \"./node_modules/melanke-watchjs/src/watch.js\");\n/* harmony import */ var melanke_watchjs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(melanke_watchjs__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _assets_application_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../assets/application.css */ \"./assets/application.css\");\n/* harmony import */ var _assets_application_css__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_assets_application_css__WEBPACK_IMPORTED_MODULE_1__);\n\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (function (state) {\n  var chessFieldDiv = document.querySelector('#chess');\n  Object(melanke_watchjs__WEBPACK_IMPORTED_MODULE_0__[\"watch\"])(state, 'chessField', function (prop, action, newValue) {\n    var chessTable = document.createElement('table');\n    var rowsKeys = Object.keys(newValue);\n    rowsKeys.forEach(function (row) {\n      var chessRow = document.createElement('tr');\n      newValue[row].forEach(function (col, i) {\n        var chessCol = document.createElement('td');\n\n        if (i === 0 || row === '0' || i === 9 || row === '9') {\n          chessCol.classList.add('borders');\n        } else {\n          chessCol.classList.add('item');\n        }\n\n        chessCol.id = \"\".concat(row, \"_\").concat(i);\n        chessCol.textContent = col; // Можно без датасетов\n        // chessCol.dataset.row = row;\n        // chessCol.dataset.col = i;\n\n        chessRow.append(chessCol);\n      });\n      chessTable.append(chessRow);\n    });\n    document.getElementById('loading').remove();\n    chessFieldDiv.append(chessTable);\n  });\n  Object(melanke_watchjs__WEBPACK_IMPORTED_MODULE_0__[\"watch\"])(state, 'checkedItem', function () {\n    var checkedItem = state.checkedItem;\n    var checkedEl = document.getElementById(checkedItem.elId);\n    checkedEl.classList.add('active');\n  });\n  Object(melanke_watchjs__WEBPACK_IMPORTED_MODULE_0__[\"watch\"])(state, 'targetItem', function () {\n    var checkedItem = state.checkedItem,\n        targetItem = state.targetItem;\n    var checkedEl = document.getElementById(checkedItem.elId);\n    checkedEl.textContent = targetItem.elText;\n    checkedEl.classList.remove('active');\n    var targetEl = document.getElementById(targetItem.elId);\n    targetEl.textContent = checkedItem.elText;\n  });\n});\n\n//# sourceURL=webpack:///./src/watcher.js?");

/***/ })

/******/ });